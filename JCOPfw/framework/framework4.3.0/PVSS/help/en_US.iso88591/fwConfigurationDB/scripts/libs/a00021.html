<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Configuration Database component: External access to ConfigurationDB (PL/SQL API)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Configuration Database component</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>External access to ConfigurationDB (PL/SQL API)</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">CDB_API_PARAMS</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Input/Output table for the PL/SQL API.  <a href="a00002.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#gabe41ab806ab9d03507f7b4806f807d43">getDevicesInRecipe</a> (VARCHAR2 recipeName, VARCHAR2 deviceFilter=null, DATE validAt=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#ga9e11b412979453780f113d042f11b0b6">getDevicesInConfiguration</a> (VARCHAR2 configurationName, VARCHAR2 deviceFilter=null)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#ga40489c9a6dcb1fd27f579811ff9af7eb">getRecipe</a> (VARCHAR2 recipeName, DATE validAt=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#gac9bd2412d265593dcae3877a3549b1cb">getRecipesList</a> (VARCHAR2 recipeNameFilter=null, VARCHAR2 deviceFilter=null, VARCHAR2 recipeCommentFilter='*', VARCHAR2 recipeTypeFilter='*')</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#ga0cdf9e94de66eddf2975e42b22f3f2d3">getConfigurationsList</a> (VARCHAR2 configurationNameFilter=null)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#gabdb0d645887faffd6d711fc2799f014b">createRecipe</a> (VARCHAR2 recipeName, VARCHAR2 recipeDescription=null)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#ga9f7a0c7948782ccf6dcde7be1cf62605">storeRecipe</a> (VARCHAR2 recipeName, VARCHAR2 versionDescription=null, VARCHAR2 userCreated=null)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#gae6405810846d53df7e0d9683e82f644c">getReferences</a> (VARCHAR2 configurationName, DATE validAt=null)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#gadf8b2a5415b776e5a53360fb026666d7">setReferences</a> (VARCHAR2 configurationName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#ga41489d6acfbac012c0e78635624f0c34">getReferenceHistory</a> (VARCHAR2 configurationName, DATE startDate=null, DATE endDate=null)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#ga021631cf4e85861d0c478ded36507957">checkInputTable</a> (NUMBER checkS2=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">fwConfigurationDB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html#ga1ab0486301d500949beeab4fe0a9cff0">t_getSequenceNumbers</a> (VARCHAR2 sequenceName, NUMBER n=1)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>External access to the data stored in the ConfigurationDB is provided by means of a PL/SQL package, containing the set of functions: </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gabe41ab806ab9d03507f7b4806f807d43"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::getDevicesInRecipe" ref="gabe41ab806ab9d03507f7b4806f807d43" args="(VARCHAR2 recipeName, VARCHAR2 deviceFilter=null, DATE validAt=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB getDevicesInRecipe </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>recipeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>deviceFilter</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DATE&#160;</td>
          <td class="paramname"><em>validAt</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds devices for which configuration data exists in a given recipe</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recipeName</td><td>- the name of the recipe which is queried </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceFilter</td><td>(optional, default null) specifies device name(s) to be checked; note that '*' and '' may be used as wildcards, and may be placed at any place within the parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">validAt</td><td>(optional, default null) allows to query historical recipes - null signifies "current recipe", otherwise a recipe as it was at the specified date will be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CDB_API_PARAMS(S1) will contain the list of matching recipes; note that the device names will be APPENDED, i.e. the previous contents of the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> are not cleared.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ORA-20001</td><td>(input data not consistent) see: <a class="el" href="a00021.html#ga021631cf4e85861d0c478ded36507957">checkInputTable</a> </td></tr>
    <tr><td class="paramname">ORA-20002</td><td>(no such recipe) the recipe specified in <code>recipeName</code> does not exist</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Example 1: </b></dt><dd>Show the devices in MyDetector/ECAL for which settings exist in the "PHYSICS/RUN" recipe <div class="fragment"><pre class="fragment">  DELETE FROM <a class="code" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a>;
  BEGIN fwConfigurationDB.getDevicesInRecipe(<span class="stringliteral">&#39;PHYSICS/RUN&#39;</span>,<span class="stringliteral">&#39;MyDetector/ECAL/%&#39;</span>);END;
  SELECT S1 from CDB_API_PARAMS;
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e11b412979453780f113d042f11b0b6"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::getDevicesInConfiguration" ref="ga9e11b412979453780f113d042f11b0b6" args="(VARCHAR2 configurationName, VARCHAR2 deviceFilter=null)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB getDevicesInConfiguration </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>configurationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>deviceFilter</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns device names present in given static configuration</p>
<p>The function returns the list of the names of devices which were saved in specified static configuration, and match specified device filter. Note that the previous contents of the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> table will be wiped out.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configurationName</td><td>- the name of the static configuration to be queried </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceFilter</td><td>(optional, default null) - allows to filter the devices; null value means no filtering (all devices in the configuration will be returned). Both: % and * may be used as wildcards.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CDB_API_PARAMS(s1) will contain the list of device names</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ORA-20002</td><td>(no such configuration) the static configuration specified in <code>configurationName</code> does not exist</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Example 1:</b></dt><dd>show all CAEN devices in all systems , in configuration called "MySetup". Note the use of wildcard characters * and % to specify all systems (the beginning of the string) and all child devices (end of the string). <div class="fragment"><pre class="fragment">    BEGIN fwConfigurationDB.getDevicesInConfiguration(<span class="stringliteral">&#39;MySetup&#39;</span>,<span class="stringliteral">&#39;*:CAEN/%&#39;</span>);END;
    SELECT s1 FROM CDB_API_PARAMS
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="ga40489c9a6dcb1fd27f579811ff9af7eb"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::getRecipe" ref="ga40489c9a6dcb1fd27f579811ff9af7eb" args="(VARCHAR2 recipeName, DATE validAt=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB getRecipe </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>recipeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DATE&#160;</td>
          <td class="paramname"><em>validAt</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets recipe data</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recipeName</td><td>- the name of recipe to query </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">validAt</td><td>(optional, default null) - allows to query historical recipes; null means: current recipe, otherwise the recipe as it was at the specified date will be returned </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDB_API_PARAMS[S1]</td><td>(optional) may contain the list of devices for which recipe data is queried; note that the original list will be altered: the order of devices may change, and only the devices for which recipe data exist will be present in this column (see below)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> table will contain the recipe data; each row represents the settings (values and alerts) for a single data point element (hence the settings for a single device may span multiple, yet consecutive, rows). Recipe data is placed in the following columns: <ul>
<li>I1 propertyId (a unique id for recipe data of a data point element) </li>
<li>I2 dp element type ("property type") - the type of data, as returned by dpElementType() function of PVSS </li>
<li>I3 recipe version: ordinal version number for recipe; a common version number is assigned to all settings stored at the same time </li>
<li>I4 determines if value ("setting") is stored in S8 </li>
<li>I5 determines if alert is configured (the details of which are in I6,I7,S5,S6,S7) </li>
<li>I6 the type of alert: one of DPCONFIG_NONE=0, DPCONFIG_ALERT_BINARYSIGNAL=12, DPCONFIG_ALERT_NONBINARYSIGNAL=13 </li>
<li>I7 determines if alert is activated </li>
<li>I8 device id (a unique id for device) </li>
<li>S1 device name </li>
<li>S2 element name </li>
<li>S3 device type (data point type) </li>
<li>S4 device model (for Framework devices) </li>
<li>S5 alert limits (list of values separated with the | character) </li>
<li>S6 alert classes (list of values separated with the | character) </li>
<li>S7 alert texts (list of values separated with the | character) </li>
<li>S8 datapoint element value(s) ("setting") </li>
<li>S9 the type of hierarchy to which the device belongs </li>
<li>D1 the time when this setting was stored (start of IOV) </li>
<li>D2 the time when this setting was replaced by another, or NULL if the setting is still valid (end of IOV) </li>
</ul>
</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ORA-20001</td><td>(input data not consistent) see: <a class="el" href="a00021.html#ga021631cf4e85861d0c478ded36507957">checkInputTable</a> </td></tr>
    <tr><td class="paramname">ORA-20002</td><td>(no such recipe) the recipe specified in <code>recipeName</code> does not exist</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Example 1:</b></dt><dd>Extract the current settings stored in recipe "PHYSICS/RUN" (for all devices for which these settings exist); print out datapoint elements and settings <div class="fragment"><pre class="fragment"> DELETE FROM CDB_API_PARAMS;
 BEGIN fwConfigurationDB.getRecipe(<span class="stringliteral">&#39;PHYSICS/RUN&#39;</span>); END;
 -- only print out the data <span class="keywordflow">for</span> which values are defined
 SELECT S1||S2, S8 FROM CDB_API_PARAMS WHERE I4=1;
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 2:</b></dt><dd>As above, but extract the recipe "PHYSICS/RUN", as it looked on 1 April 2007. <div class="fragment"><pre class="fragment"> DELETE FROM CDB_API_PARAMS;
 BEGIN fwConfigurationDB.getRecipe(<span class="stringliteral">&#39;PHYSICS/RUN&#39;</span>, TO_DATE(<span class="stringliteral">&#39;2007-04-01&#39;</span>,<span class="stringliteral">&#39;YYYY-MM-DD&#39;</span>)); END;
 SELECT S1||S2, S8 FROM CDB_API_PARAMS WHERE I4=1;
</pre></div></dd></dl>
<dl class="user"><dt><b>Example 3:</b></dt><dd>Get current settings from recipe "PHYSICS/RUN" for two selected devices: "MyDetector/ECAL/HV/chn1" and "MyDetector/ECAL/HV/chn2" <div class="fragment"><pre class="fragment"> DELETE FROM CDB_API_PARAMS;
 INSERT INTO CDB_API_PARAMS(S1) VALUES &#39;MyDetector/ECAL/HV/chn1&#39;;
 INSERT INTO CDB_API_PARAMS(S1) VALUES &#39;MyDetector/ECAL/HV/chn2&#39;;
 BEGIN fwConfigurationDB.<a class="code" href="a00021.html#ga40489c9a6dcb1fd27f579811ff9af7eb">getRecipe</a>(&#39;PHYSICS/RUN&#39;);END;
 SELECT * FROM CDB_API_PARAMS;
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="gac9bd2412d265593dcae3877a3549b1cb"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::getRecipesList" ref="gac9bd2412d265593dcae3877a3549b1cb" args="(VARCHAR2 recipeNameFilter=null, VARCHAR2 deviceFilter=null, VARCHAR2 recipeCommentFilter='*', VARCHAR2 recipeTypeFilter='*')" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB getRecipesList </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>recipeNameFilter</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>deviceFilter</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>recipeCommentFilter</em> = <code>'*'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>recipeTypeFilter</em> = <code>'*'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get list of recipes or find a recipe</p>
<p>The function returns the list of names of recipes that fulfil certain criteria. By default (with all parameters set to default values) it returns the list of all recipes in the database. Note that the function wipes out the previous content of the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> table.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recipeNameFilter</td><td>(optional, default null) allows to filter on the recipe name; wildcards ('*' or '' characters) are allowed. Specifying null will disable this selection criteria (i.e. all recipes matching the remaining criteria will be returned). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceFilter</td><td>(optional, default null) allows to search for recipe which contain specified device(s). This parameter may contain wildcards ( '*' or '' characters), so that any device matching the specified filter will be approved. Specifying null will disable this selection criteria (i.e. all recipes matching the remaining criteria will be returned). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recipeCommentFilter</td><td>(optional, default '*') allows to filter on the recipe comment; wildcards ('*' or '' characters) are allowed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recipeTypeFilter</td><td>(optional, default '*') allows to filter on the recipe type; wildcards ('*' or '' characters) are allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> will contain the names and the meta-information describing the recipes in the following columns: <ul>
<li>S1 recipe name </li>
<li>S2 recipe comment </li>
<li>S3 recipe type Note that if no matching recipes are found, the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> will be empty.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Example 1:</b></dt><dd>Show the names of recipes which have any CAEN devices inside, and its name starts with "PHYSICS": <div class="fragment"><pre class="fragment">    BEGIN fwConfigurationDB.getRecipesList(<span class="stringliteral">&#39;PHYSICS/%&#39;</span>,<span class="stringliteral">&#39;*CAEN*&#39;</span>); END;
    SELECT S1 FROM CDB_API_PARAMS;
</pre></div> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cdf9e94de66eddf2975e42b22f3f2d3"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::getConfigurationsList" ref="ga0cdf9e94de66eddf2975e42b22f3f2d3" args="(VARCHAR2 configurationNameFilter=null)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB getConfigurationsList </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>configurationNameFilter</em> = <code>null</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the list of available static configurations</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configurationNameFilter</td><td>(optional, default null) allows to filter on configuration names: the '*' and '' wildcards are allowed; null means: get all configuration names</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a>[S1] will contain the list of configuration names</dd></dl>
<p>Note that the previous contents of the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> table will be wiped out. </p>

</div>
</div>
<a class="anchor" id="gabdb0d645887faffd6d711fc2799f014b"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::createRecipe" ref="gabdb0d645887faffd6d711fc2799f014b" args="(VARCHAR2 recipeName, VARCHAR2 recipeDescription=null)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB createRecipe </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>recipeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>recipeDescription</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new recipe with given name and comment</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recipeName</td><td>the name for the recipe </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recipeDescription</td><td>(optional, default null) the comment for the recipe</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ORA-20002</td><td>(recipe already exists) the recipe specified in <code>recipeName</code> already exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f7a0c7948782ccf6dcde7be1cf62605"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::storeRecipe" ref="ga9f7a0c7948782ccf6dcde7be1cf62605" args="(VARCHAR2 recipeName, VARCHAR2 versionDescription=null, VARCHAR2 userCreated=null)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB storeRecipe </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>recipeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>versionDescription</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>userCreated</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores a new version of recipe data</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recipeName</td><td>- the name of the recipe </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">versionDescription</td><td>(optional, default null) text indicating the reason for this new version </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userCreated</td><td>(optional, default null) the name of the user who created this version </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname"><a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a></td><td>table needs to be filled with recipe data; each row contains settings for one data point element. The data should be placed in the following columns: </p>
<ul>
<li>S1 device name </li>
<li>S2 device element name (including leading dot!) </li>
<li>I1 (optionally) may contain PropId (i.e. known from loading a recipe previously), see below in examples </li>
<li>I4 should be set to 1 if value ("setting") is available </li>
<li>I5 should be set to 1 if alarm is configured</li>
</ul>
<p>The following column need to be filled with valid data, if value is specified (i.e. I4=1), otherwise they may contain NULL: </p>
<ul>
<li>S8 contains the value ("setting"). For values being lists, the elements should be concatenated into a string, separated using the | character</li>
</ul>
<p>The following columns need to be filled with valid data, if alert is specified (i.e. I5=1), otherwise they may contain NULL: </p>
<ul>
<li>I6 alert type; the alert type may be one of DPCONFIG_NONE=0, DPCONFIG_ALERT_BINARYSIGNAL=12, DPCONFIG_ALERT_NONBINARYSIGNAL=13 </li>
<li>I7 alert active flag; 1 means alert is active </li>
<li>S6 alert classes; the names of alert classes should be concatenated and separated using the | character. Note that for there needs to be an empty alert class that signifies the valid alert range! For instance "|_fwErrorAck" or "_fwErrorAck||_fwErrorAck" or "_fwErrorAck|" (note the trailing | character in this last example!) </li>
<li>S7 alert texts; texts needs to be concatenated and separated using the | character </li>
<li>S5 alert limits; limits need to be concatenated and separated using the | character </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ORA-20002</td><td>(no such recipe) the recipe specified in <code>recipeName</code> does not exist </td></tr>
    <tr><td class="paramname">ORA-20023</td><td>(no such device) a device has not been stored in any of existing static configurations </td></tr>
    <tr><td class="paramname">ORA-20024</td><td>(no such device element) a device has no such element</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Note: the contents of <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> may be undefined and will differ from the one passed as an input! Internally, the following data is filled in the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a>: <ul>
<li>I8: DPID (datapoint ID) </li>
<li>I1: IPROP_ID - assigned for records that do not have it </li>
<li>I2: DEVELEM_ID (DP element ID) </li>
<li>I3: RVER (recipe version ID ) </li>
<li>I4: marks (sets to 1) the devices that do not need to be invalidated</li>
</ul>
For a set of examples, refer to the main page of <a class="el" href="a00021.html">External access to ConfigurationDB (PL/SQL API)</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gae6405810846d53df7e0d9683e82f644c"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::getReferences" ref="gae6405810846d53df7e0d9683e82f644c" args="(VARCHAR2 configurationName, DATE validAt=null)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB getReferences </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>configurationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DATE&#160;</td>
          <td class="paramname"><em>validAt</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the mapping between devices and aliases</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configurationName</td><td>the name of static configuration from which the mapping should be retrieved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">validAt</td><td>(optional, default null) if not null, allows to query historical mapping. The mapping that is returned is the one that was in the Configuration Database at the time specified using this parameter. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">CDB_API_PARAMS[s1]</td><td>(optional) may contain the list of aliases for which the mapping is queried; if <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> is empty, the mapping for all devices will be returned. Note that the contents of the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> will be altered - you may not assume the order of items, and the presence of all aliases you placed there on input!</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> will contain the mapping in the following columns <ul>
<li>S1 device alias </li>
<li>S2 device (datapoint) name to which the alias points </li>
<li>S3 hierarchy type of the device in S1 </li>
<li>S4 hierarchy type of the device in S2 </li>
<li>D1 the time this mapping was stored (i.e. became effective) </li>
<li>D2 the time this mapping was replaced by other mapping (i.e. the end of validity for historical mapping), or NULL if the mapping is still valid </li>
<li>I1 device alias ID </li>
<li>I2 refered (device) ID</li>
</ul>
</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ORA-20001</td><td>(input data not consistent) see: <a class="el" href="a00021.html#ga021631cf4e85861d0c478ded36507957">checkInputTable</a> </td></tr>
    <tr><td class="paramname">ORA-20005</td><td>(no such configuration) the static configuration specified in <code>configurationName</code> does not exist </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf8b2a5415b776e5a53360fb026666d7"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::setReferences" ref="gadf8b2a5415b776e5a53360fb026666d7" args="(VARCHAR2 configurationName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB setReferences </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>configurationName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores a new mapping between devices and aliases</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configurationName</td><td>the name of static configuration to which the mapping should be stored </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"><a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a></td><td>needs to be filled in with the following information </p>
<ul>
<li>S1 the alias </li>
<li>S2 the datapoint (device) to which the alias should be pointing</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ORA-20005</td><td>(no such configuration) the static configuration specified in <code>configurationName</code> does not exist </td></tr>
    <tr><td class="paramname">ORA-20021</td><td>(device list not unique) one or more devices in S2 column does not exist in the static configuration, or it is given more than once, or it is null </td></tr>
    <tr><td class="paramname">ORA-20022</td><td>(alias list not unique) one or more aliases in S1 column does not exist in the static configuration, or it is given more than once, or it is null </td></tr>
    <tr><td class="paramname">ORA-20023</td><td>(no such alias) an alias does not exist in any of static configurations </td></tr>
    <tr><td class="paramname">ORA-20024</td><td>(no such device) a device does not exist in any of static configurations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41489d6acfbac012c0e78635624f0c34"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::getReferenceHistory" ref="ga41489d6acfbac012c0e78635624f0c34" args="(VARCHAR2 configurationName, DATE startDate=null, DATE endDate=null)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB getReferenceHistory </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>configurationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DATE&#160;</td>
          <td class="paramname"><em>startDate</em> = <code>null</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DATE&#160;</td>
          <td class="paramname"><em>endDate</em> = <code>null</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the history of mappings for given aliases</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">configurationName</td><td>- the name of static configuration to be queried </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startDate</td><td>(optional, default null) the start of the period to query; null means no start limit: get the history starting from the first available entries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endDate</td><td>(optional, default null) the end of the period to query; null means no end limit: get the history up to the current mapping </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CDB_API_PARAMS[S1]</td><td>(optional) may contain the aliases for which the mapping is being queried; if the table is empty, the mapping for all aliases will be queried (carefully! this may be a lot of data!)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> will be filled with possibly multiple records per every alias: a single line indicates one IOV (Interval of Validity) per one device. The data will be in the following columns: <ul>
<li>S1 device alias </li>
<li>S2 device dpname refered to by the alias </li>
<li>S3 hierarchy type of S1 </li>
<li>S4 hierarchy type of S2 </li>
<li>D1 start of IOV for this mapping </li>
<li>D2 end of IOV for this mapping </li>
<li>I1 device alias ID </li>
<li>I2 refered (device) ID</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Example 1:</b></dt><dd>show the changes to the mapping for aliases MyDetector/ECAL/chn1 and MyDetector/ECAL/chn2 performed throughout the month of April 2007, stored in static configuration "MySetup". <div class="fragment"><pre class="fragment"> DELETE FROM CDB_API_PARAMS;
 INSERT INTO CDB_API_PARAMS(s1) VALUES &#39;MyDetector/ECAL/chn1&#39;;
 INSERT INTO CDB_API_PARAMS(s1) VALUES &#39;MyDetector/ECAL/chn2&#39;;
 BEGIN 
    fwConfigurationDB.<a class="code" href="a00021.html#ga41489d6acfbac012c0e78635624f0c34">getReferenceHistory</a>(&#39;MySetup&#39;, 
        TO_DATE(&#39;2007-04-01&#39;,&#39;YYYY-MM-DD&#39;), 
        TO_DATE(&#39;2007-04-30&#39;,&#39;YYYY-MM-DD&#39;)
    );
 END;
 SELECT S1 Alias, S2 Device , D1 Since, D2 Till from CDB_API_PARAMS;
</pre></div> This example might hypotetically return the following results: <div class="fragment"><pre class="fragment"> |---------------------|------------------------------|-----------|------------|
 | Alias               | Device                       | Since     | Till       |
 |---------------------|------------------------------|-----------|------------|
 |MyDetector/ECAL/chn1 |dist_1:CAEN/crate1/bd00/chn00 |2006-10-12 | 2007-04-05 |
 |MyDetector/ECAL/chn1 |dist_1:CAEN/crate1/bd10/chn05 |2007-04-05 | 2007-04-10 |
 |MyDetector/ECAL/chn1 |dist_1:CAEN/crate1/bd00/chn00 |2007-04-10 | NULL       |
 |MyDetector/ECAL/chn2 |dist_1:CAEN/crate1/bd00/chn01 |2007-04-03 | 2007-04-05 |
 |MyDetector/ECAL/chn2 |dist_1:CAEN/crate2/bd12/chn02 |2007-04-10 | 2007-06-20 |
 |---------------------|------------------------------|-----------|------------|
</pre></div> These results may be interpretted as follows: <ul>
<li>first three lines contain information about the first alias, the remaining ones - about the second alias - this is indicated by the value in the first column </li>
<li>The first alias was pointing to crate1/bd00/chn00 until 2007-04-05, and it was the mapping that was valid since 2006-10-12. We do not know what was the mapping before. </li>
<li>The mapping for the first alias changed twice in the month or April, and the last change (which actually reversed the first change) is still valid up till now (note the NULL value </li>
<li>The second alias was added (or reactivated) only on 2007-04-03. Before the 1st of April it did not exist. The mapping in the fourth line lasted till 5th of April, then the device was deleted - this can be seen by looking at the "Since" value in the next line - it differs from the "Till" column. </li>
<li>The second device was added again on 10th of April, and the mapping lasted till 2007-06-20, at which date the mapping has changed: the device alias was either deleted again, or its mapping has changed to something else. One could not tell the reason: the query was executed with <code>endDate</code> set to end of April; one would need to specify null as the <code>endDate</code> to see the history past the end of April.</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga021631cf4e85861d0c478ded36507957"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::checkInputTable" ref="ga021631cf4e85861d0c478ded36507957" args="(NUMBER checkS2=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fwConfigurationDB checkInputTable </td>
          <td>(</td>
          <td class="paramtype">NUMBER&#160;</td>
          <td class="paramname"><em>checkS2</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks the consistency of the data in the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> table</p>
<p>SCOPE OF USE: Internal</p>
<p>The function checks if all columns (except S1, and - depending on <code>checkS2</code> parameter - also S2) in the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> are empty. This is to make sure that the user did not forget to clean up the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> table after the previous use. This function is called internally by most of the function in the package. The function also returns the number of rows in the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a>, i.e. the number of input records.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">checkS2</td><td>(default 1) determines if the S2 column should be checked. Passing NULL will result in S2 not being checked (i.e. signifies that S2 contain valid data).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of rows in the <a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a> table</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">ORA-20001</td><td>(fwConfigurationDB: Input table CDB_API_PARAM not consistent. Forgot to TRUNC it before use?) is reported if the data is not consistent (i.e. the table contains the data which is not acceptable as input to the procedure - S1 or/and S2 columns are not empty) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1ab0486301d500949beeab4fe0a9cff0"></a><!-- doxytag: member="fwConfigurationDB_TechnicalDocumentation.ctl::t_getSequenceNumbers" ref="ga1ab0486301d500949beeab4fe0a9cff0" args="(VARCHAR2 sequenceName, NUMBER n=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fwConfigurationDB t_getSequenceNumbers </td>
          <td>(</td>
          <td class="paramtype">VARCHAR2&#160;</td>
          <td class="paramname"><em>sequenceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NUMBER&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws a set of numbers from named sequence</p>
<p>The function draws a set of <code>n</code> numbers from sequence called <code>sequenceName</code> .</p>
<p>SCOPE OF USE: Internal</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sequenceName</td><td>the name of sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>the number of sequence numbers to draw (default: one)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>on return the sequence numbers will be placed in column <code>I1</code> of table <code><a class="el" href="a00002.html" title="Input/Output table for the PL/SQL API.">CDB_API_PARAMS</a></code> ; </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 15 2011 for Configuration Database component by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
